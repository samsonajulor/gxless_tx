var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/biconomyWrapProvider.ts
import EventEmitter from "events";
var SendTransactionMode = /* @__PURE__ */ ((SendTransactionMode2) => {
  SendTransactionMode2[SendTransactionMode2["UserSelect"] = 0] = "UserSelect";
  SendTransactionMode2[SendTransactionMode2["Gasless"] = 1] = "Gasless";
  SendTransactionMode2[SendTransactionMode2["UserPaidNative"] = 2] = "UserPaidNative";
  return SendTransactionMode2;
})(SendTransactionMode || {});
var SendTransactionEvent = /* @__PURE__ */ ((SendTransactionEvent2) => {
  SendTransactionEvent2["Request"] = "RequestSendTransaction";
  SendTransactionEvent2["Resolve"] = "ResolveSendTransaction";
  SendTransactionEvent2["Reject"] = "RejectSendTransaction";
  return SendTransactionEvent2;
})(SendTransactionEvent || {});
var BiconomyWrapProvider = class {
  constructor(smartAccount, sendTxMode = 2 /* UserPaidNative */) {
    this.smartAccount = smartAccount;
    this.sendTxMode = sendTxMode;
    this.events = new EventEmitter();
    this.events.setMaxListeners(100);
    if (!Object.values(SendTransactionMode).includes(sendTxMode)) {
      throw new Error(`sendTxMode value error, must in ${Object.values(SendTransactionMode)}`);
    }
  }
  resolveSendTransaction(feeQuote) {
    this.events.emit("ResolveSendTransaction" /* Resolve */, feeQuote);
  }
  rejectSendTransaction(error) {
    this.events.emit("RejectSendTransaction" /* Reject */, error);
  }
  on(event, listener) {
    if ("RequestSendTransaction" /* Request */ === event) {
      this.events.on(event, listener);
    } else {
      this.smartAccount.provider.on(event, listener);
    }
  }
  once(event, listener) {
    if ("RequestSendTransaction" /* Request */ === event) {
      this.events.once(event, listener);
    } else {
      this.smartAccount.provider.once(event, listener);
    }
  }
  off(event, listener) {
    if ("RequestSendTransaction" /* Request */ === event) {
      this.events.off(event, listener);
    } else {
      this.smartAccount.provider.off(event, listener);
    }
  }
  removeListener(event, listener) {
    if ("RequestSendTransaction" /* Request */ === event) {
      this.events.removeListener(event, listener);
    } else {
      this.smartAccount.provider.removeListener(event, listener);
    }
  }
  enable() {
    return this.request({
      method: "eth_requestAccounts"
    });
  }
  request(payload) {
    return __async(this, null, function* () {
      if (payload.method === "eth_requestAccounts" || payload.method === "eth_accounts") {
        yield this.smartAccount.provider.request(payload);
        const address = yield this.smartAccount.getAddress();
        return [address];
      } else if (payload.method === "eth_sendTransaction") {
        if (!payload.params) {
          return Promise.reject(new Error("send transaction param error"));
        }
        const txData = payload.params[0];
        if (this.sendTxMode === 2 /* UserPaidNative */) {
          const feeQuotes2 = yield this.smartAccount.getFeeQuotes(txData);
          return this.smartAccount.sendUserPaidTransaction(txData, feeQuotes2[0]);
        } else if (this.sendTxMode === 1 /* Gasless */) {
          return this.smartAccount.sendGaslessTransaction(txData);
        }
        const feeQuotes = yield this.smartAccount.getFeeQuotes(txData);
        return new Promise((resolve, reject) => {
          this.events.removeAllListeners("RejectSendTransaction" /* Reject */);
          this.events.removeAllListeners("ResolveSendTransaction" /* Resolve */);
          this.events.once("ResolveSendTransaction" /* Resolve */, (feeQuote) => __async(this, null, function* () {
            let txHash;
            try {
              if (feeQuote) {
                txHash = yield this.smartAccount.sendUserPaidTransaction(txData, feeQuote);
              } else {
                txHash = yield this.smartAccount.sendGaslessTransaction(txData);
              }
              resolve(txHash);
            } catch (error) {
              reject(error);
            }
          }));
          this.events.once("RejectSendTransaction" /* Reject */, reject);
          this.events.emit("RequestSendTransaction" /* Request */, feeQuotes);
        });
      }
      return this.smartAccount.provider.request(payload);
    });
  }
};

// src/smartAccount.ts
import axios from "axios";

// src/utils.ts
var rpcUrl = () => {
  const productionApi = "https://rpc.particle.network";
  const developmentApi = "https://rpc-debug.particle.network";
  const dev = typeof window !== "undefined" && window.__PARTICLE_ENVIRONMENT__ === "development";
  return dev ? developmentApi : productionApi;
};
function payloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}

// src/smartAccount.ts
var SmartAccount = class {
  constructor(provider, config) {
    this.provider = provider;
    this.config = config;
    this.connection = axios.create({
      baseURL: `${rpcUrl()}/evm-chain`,
      timeout: 6e4
    });
    this.getChainId = () => __async(this, null, function* () {
      return yield this.provider.request({ method: "eth_chainId" });
    });
  }
  getDappAPIKey() {
    return __async(this, null, function* () {
      const chainId = yield this.getChainId();
      const networkConfig = this.config.networkConfig.find((item) => item.chainId === Number(chainId));
      if (networkConfig) {
        return networkConfig.dappAPIKey;
      }
      return Promise.reject(
        new Error(`Current chain is not supported, chainId: ${chainId}, please configure it first`)
      );
    });
  }
  checkCurrentChain() {
    return __async(this, null, function* () {
      yield this.getDappAPIKey();
    });
  }
  getFeeQuotes(tx) {
    return __async(this, null, function* () {
      yield this.checkCurrentChain();
      const eoa = (yield this.provider.request({ method: "eth_accounts" }))[0];
      const feeQuotes = yield this.sendRpc({
        method: "particle_biconomy_getFeeQuotes",
        params: ["1.0.0", eoa, Array.isArray(tx) ? tx : [tx]]
      });
      return feeQuotes;
    });
  }
  createUserPaidTransaction(tx, feeQuote) {
    return __async(this, null, function* () {
      yield this.checkCurrentChain();
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      return yield this.sendRpc({
        method: "particle_biconomy_createUserPaidTransaction",
        params: ["1.0.0", eoas[0], Array.isArray(tx) ? tx : [tx], feeQuote]
      });
    });
  }
  sendUserPaidSignedTransaction(walletTx, signature) {
    return __async(this, null, function* () {
      yield this.checkCurrentChain();
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      const hash = yield this.sendRpc({
        method: "particle_biconomy_sendUserPaidTransaction",
        params: ["1.0.0", eoas[0], walletTx, signature]
      });
      return hash;
    });
  }
  sendUserPaidTransaction(tx, feeQuote) {
    return __async(this, null, function* () {
      yield this.checkCurrentChain();
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      const userPaidTx = yield this.createUserPaidTransaction(tx, feeQuote);
      const signature = yield this.provider.request({
        method: "eth_signTypedData_v4",
        params: [eoas[0], JSON.stringify(userPaidTx.typedData)]
      });
      return this.sendUserPaidSignedTransaction(userPaidTx.walletTransaction, signature);
    });
  }
  createGaslessTransaction(tx) {
    return __async(this, null, function* () {
      const apiKey = yield this.getDappAPIKey();
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      const gaslessTx = yield this.sendRpc({
        method: "particle_biconomy_createGaslessTransaction",
        params: ["1.0.0", eoas[0], Array.isArray(tx) ? tx : [tx], apiKey]
      });
      return gaslessTx;
    });
  }
  sendGaslessSignedTransaction(userOp, signature) {
    return __async(this, null, function* () {
      const apiKey = yield this.getDappAPIKey();
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      return yield this.sendRpc({
        method: "particle_biconomy_sendGaslessTransaction",
        params: [
          "1.0.0",
          eoas[0],
          __spreadProps(__spreadValues({}, userOp), {
            signature
          }),
          apiKey
        ]
      });
    });
  }
  sendGaslessTransaction(tx) {
    return __async(this, null, function* () {
      const gaslessTx = yield this.createGaslessTransaction(tx);
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      const signature = yield this.provider.request({
        method: "personal_sign",
        params: [gaslessTx.userOpHash, eoas[0]]
      });
      return yield this.sendGaslessSignedTransaction(gaslessTx.userOp, signature);
    });
  }
  getAccount() {
    return __async(this, null, function* () {
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      const accounts = yield this.sendRpc({
        method: "particle_biconomy_getSmartAccount",
        params: ["1.0.0", eoas]
      });
      return accounts[0];
    });
  }
  getAddress() {
    return __async(this, null, function* () {
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      if (!eoas || eoas.length === 0) {
        return "";
      }
      if (typeof window !== "undefined" && localStorage) {
        const localAA = localStorage.getItem(`particle_biconomy_${eoas[0]}`);
        if (localAA) {
          return localAA;
        }
      }
      const account = yield this.getAccount();
      const address = account.smartAccountAddress;
      if (typeof window !== "undefined" && localStorage) {
        localStorage.setItem(`particle_biconomy_${eoas[0]}`, address);
      }
      return address;
    });
  }
  getOwner() {
    return __async(this, null, function* () {
      const eoas = yield this.provider.request({ method: "eth_accounts" });
      return eoas[0];
    });
  }
  isDeployed() {
    return __async(this, null, function* () {
      const account = yield this.getAccount();
      return account.isDeployed;
    });
  }
  deployWalletContract() {
    return __async(this, null, function* () {
      return yield this.sendGaslessTransaction({
        to: "0x0000000000000000000000000000000000000000",
        data: "0x"
      });
    });
  }
  sendRpc(arg) {
    return __async(this, null, function* () {
      const chainId = yield this.getChainId();
      const response = yield this.connection.post(
        "",
        __spreadProps(__spreadValues({}, arg), {
          id: payloadId(),
          jsonrpc: "2.0"
        }),
        {
          params: {
            chainId: Number(chainId),
            projectUuid: this.config.projectId,
            projectKey: this.config.clientKey
          }
        }
      ).then((res) => res.data);
      if (response.error) {
        return Promise.reject(response.error);
      } else {
        return response.result;
      }
    });
  }
};
export {
  BiconomyWrapProvider,
  SendTransactionEvent,
  SendTransactionMode,
  SmartAccount
};
//# sourceMappingURL=index.js.map
